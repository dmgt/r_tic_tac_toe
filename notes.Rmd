---
title: "Tic Tac Toe"
output: github_notebook
editor_options: 
  chunk_output_type: console
---

```{r setup, message= F}
library(glue)  # for helpful defaults for print statements in R
library(purrr) # For functions to map over a vector (specifically `map_int()` below)
library(magrittr) # For 'pipe' operator ( %>% ) to specify operations from left to right w/o nested function calls
```

## Functions

### Helper functions
```{r}

initial_prompt <- function()  {
  
      
            #Initialize
             player_1_moves <- c()
             player_2_moves <- c()
  
  print(glue("
                                                                     
             Welcome to tic-tac-toe!
             
             This is a game for two players. The goal is to get three x's or o's in a row on the board 
             (in any order - horizontal, vertical, or diagonal)

             You can take turns entering your move at this prompt. 
             There are a total of 9 positions on the board, each indicated with a number, as shown below:
             
             ")) 
        
                
             plot_board(player_1_moves, player_2_moves)
                        
  print(glue("
             
                          Player 1 will go first. Your plays will use the 'x' symbol on the board. Player 2 is 'o'.
             
             "))
                     
  
  n <- (readline("Player 1, what's your first move? Please enter a number from 1-9: "))
  n <- as.numeric(n)
  
  list(n=n)
}

 player2_initial_prompt <- function(){
    n <- (readline("Player 2, it's time for your first move with 'o', please enter a number from 1-9: "))
    n <- as.numeric(n)
  
  list(n=n)
 }
 
midgame_prompt <- function(player_number){
    n <- (readline(glue("Player {player_number}, your turn. Please enter a number from 1-9: ")))
    n <- as.numeric(n)
  
  list(n=n)
 }
 
```

```{r}
# Plotting the board - shows all digits if player_moves is NULL 
# Initially adapted from example that used a v. different numbering scheme https://www.robert-hickman.eu/post/r-inforcement_learning_one/
plot_board <- function(player_1_moves, player_2_moves ) {
  
  board_numbers <- c(1:9)
  
   for (i in board_numbers)
  {
    if (i %in% player_1_moves)  board_numbers[i] <- "x"
    if (i %in% player_2_moves)  board_numbers[i] <- "o"
    }
  
  board_elements <- glue_collapse(board_numbers, sep = " | ")
 
  board_lines <- gsub("(. \\| . \\| . )\\|( . \\| . \\| . )\\|( . \\| . \\| .)", 
                      "\n \\1\n-----------\n\\2\n-----------\n\\3",
                      board_elements
                      )
  return(writeLines(board_lines))
}
```

```{r}
# This function is called below only *after* the following objects have been initialized
  ##  player_1_moves 
  ##  player_2_moves 
  ##  results <- list(continue_play = T, winner = NA)  # initial conditions
  ##
evaluate_win_conditions <-function(player_1_moves, player_2_moves) {

  #Enumerate winning combinations of positions (as sets where elements can occur in any order)
  list_of_winning_moves <- list(c(1,2,3), c(4,5,6), c(7,8,9), c(1,4,7), c(2,5,8), c(3,6,9), c(1,5,9), c(3,5,7))
  
  # Map return a list, map_int simplifies the output to a vector of integers
  p1_results <- map_int(list_of_winning_moves, function(x) is.element(unlist(x), player_1_moves) %>% sum() )  
  p2_results <- map_int(list_of_winning_moves, function(x) is.element(unlist(x), player_2_moves) %>% sum() ) 

if (max(p1_results) == 3 ) {
    results$continue_play <- F
    results$winner <- "Player 1" 
  } else if (max(p2_results) == 3 ){ 
    results$continue_play <- F
    results$winner <- "Player 2" }
  
 results <- list(continue_play = results$continue_play, winner =  results$winner)
  
}

play_again_prompt <- function() {
    c <- (readline(glue("Would you like to play again? Please enter Y for 'Yes' or N for 'No': ")))
    c <- as.character(c)
  
  list(c = c)
}  
```

 
```{r}

tic_tac_toe <- function ()  {
  
    # Initialize empty vectors to store moves from each player
    player_1_moves <- c()
    player_2_moves <- c()
  

   #### First move by player 1 ####
   inputs <- initial_prompt() # Trigger text input prompt
  
   p1_next_move <- inputs$n # Extract value from text input prompt
   player_1_moves <- append(player_1_moves, p1_next_move)
   
   plot_board(player_1_moves, player_2_moves) 
   
   
   #### First move by player 2 ####
   inputs2 <- player2_initial_prompt()
   
   p2_next_move <- inputs2$n
   player_2_moves <- append(player_2_moves, p2_next_move)
   
   plot_board(player_1_moves, player_2_moves)
   
   #### Initialize conditions ####
   results <- list(continue_play = T, winner = NA)
   
   #### Function to test for win conditions #### 
   evaluate_win_conditions <-function(player_1_moves, player_2_moves) {

      #Enumerate winning combinations of positions (as sets where elements can occur in any order)
      list_of_winning_moves <- list(c(1,2,3), c(4,5,6), c(7,8,9), c(1,4,7), c(2,5,8), c(3,6,9), c(1,5,9), c(3,5,7))
  
      # Map return a list, map_int simplifies the output to a vector of integers
      p1_results <- map_int(list_of_winning_moves, function(x) is.element(unlist(x), player_1_moves) %>% sum() )  
      p2_results <- map_int(list_of_winning_moves, function(x) is.element(unlist(x), player_2_moves) %>% sum() ) 

      if (max(p1_results) == 3 ) {
          results$continue_play <- F
          results$winner <- "Player 1" 
        } else if (max(p2_results) == 3 ){ 
          results$continue_play <- F
          results$winner <- "Player 2" }
        
       results <- list(continue_play = results$continue_play, winner =  results$winner)
      }
   
  #### While loop with next moves by both players ####
   
   while (results$continue_play == T ){
     
      # Player 1
      player1_inputs <- midgame_prompt(player_number = 1)
      p1_next_move <- player1_inputs$n
      player_1_moves <- append(player_1_moves, p1_next_move)
   
      plot_board(player_1_moves, player_2_moves)
   
      results <- evaluate_win_conditions(player_1_moves, player_2_moves) 
      
      if (results$continue_play == F) { break }
      else {
      
      player2_inputs <- midgame_prompt(player_number = 2)
      p2_next_move <- player2_inputs$n
      player_2_moves <- append(player_2_moves, p2_next_move)
   
      plot_board(player_1_moves, player_2_moves)
   
      results <- evaluate_win_conditions(player_1_moves, player_2_moves)
        
      } # end of else statement
       } # end of while loop
    
    #### End of game  - check if want to play again ###
   
        print(glue("Congrats, {results$winner}, you won! "))
        
         yes_no <- play_again_prompt()
         yes_no_choice <- yes_no$c
         
         if(yes_no_choice %in% c("N","n")) {
           
           print(glue("Game over"))
          
           } else if(yes_no_choice %in% c("Y","y")) {
             
             tic_tac_toe()
             
           } else {print(glue("Sorry, '{yes_no_choice}' is not a valid input"))
             
                # Repeat choices above
                yes_no <- play_again_prompt()
                yes_no_choice <- yes_no$c
                
                if(yes_no_choice %in% c("N","n")) {
                  print(glue("Game over"))
                  } else if(yes_no_choice %in% c("Y","y")) {
                    tic_tac_toe()
                  } else {print(glue("Sorry, this doesn't seem to be working out. Game over."))}
                    
            } # End of else statement
             
        } # End of function
     
  
```

## Interim notes

_ Lists in R *are * ordered, even though they can also be named - good writeup: https://stackoverflow.com/questions/2050790/how-to-correctly-use-lists-in-r 
- R base set operations are set up to work on vectors
- Trying to create a tibble from vectors like this does not work and only reads the first vector: `as_tibble(c(1,2,3), c(4,5,6), c(7,8,9), c(1,4,7), c(2,5,8), c(3,6,9), c(1,5,9), c(3,5,7))`
- sapply is a simplified version of lapply output (lapply returns a list same length as original element)

- Can use combinat::permn to generate all permutations of a vector
- Can use `purrr::map2()` to operate on 2 things eg "(data = DATA FOR ONE SPECIES, n = SAMPLE SIZE)", per https://jennybc.github.io/purrr-tutorial/ls12_different-sized-samples.html


## Steps and desired feautures

- Two humans play against each other
- A message when the function is first called: eg  "Welcome to tic tac toe! This is a game for two players. The goal is to get three x's or o's in a row!

You can take turns entering your move in this window. There are a total of 9 positions on the board, as show below: 
" - Done
- Optional - flip a coin to decide who goes first

- Initialize sets to store moves from each player - Done

- A new message that shows the state of the board and promps one player to enter their move (from 1 to 9) - Done

- The number the first player enters is added to their set of moves - Done

- State of board is updated, and the second player is prompted to enter their move - Done

- Loop three steps above, evaluating win conditions at each iteration
    - There are 8 possible configurations for each player to win, which are easy to list as a set (order doesn't matter)


## Notes
- Taking in input from the prompt is not a functionality I have used before in R, but it definately exists (see eg packages built to provide in-IDE tutorials from an R package such as `swirl`)

### R features
- https://www.datamentor.io/r-programming/examples/user-input/
- https://stackoverflow.com/questions/33425727/calling-user-inputs-prompted-through-one-r-function-in-a-second-r-function 

- Existing R package (haven't looked at the code) https://github.com/kota7/tictactoe 
- Implementation that includes a way to code  grid to plot: https://www.robert-hickman.eu/post/r-inforcement_learning_one/ 

### Tic tac toe and deadling with user input in other languages
- https://towardsdatascience.com/tic-tac-toe-creating-unbeatable-ai-with-minimax-algorithm-8af9e52c1e7d
- https://stackoverflow.com/questions/23294658/asking-the-user-for-input-until-they-give-a-valid-response

